---
title: Item 13. clone 재정의는 주의해서 진행하라
categories: [Effective-Java]
tags: [clone]
toc: true

date: 2022-06-01
last_modified_at: 2022-06-01
---

## 1. 들어가기

clone 메서드를 직접 사용해본 경험이 있나요?

Object를 상속 받는 모든 클래스는 clone 메서드를 호출할 수 있습니다.

하지만, 저는 clone 메서드를 호출해 본 경험은 없네요...

그래서 먼저, clone 메서드가 어떤 역할을 하는지 알아보도록 하겠습니다.

## 2. clone 메서드

clone 메서드는 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성합니다.

즉, 여러 정보를 담은 객체를 복제해서 그 객체와 똑같은 정보를 가진 또 하나의 객체를 생성하는 것입니다.

하지만, 모든 클래스가 이 clone 메서드를 호출할 수 있는 것은 아닙니다.

바로, Cloneable이라는 인터페이스가 구현된 클래스여야 호출 가능합니다.

Cloneable 인터페이스가 구현되지 않았는데 clone 메서드를 호출하게 되면

CloneNotSupportedException 예외가 발생합니다.

```java
/* CloneTest 클래스 */
    public class CloneTest {
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }

/* Client */
    CloneTest test1 = new CloneTest();
    CloneTest test2 = (CloneTest) test1.clone();
```
```
    Exception in thread "main" java.lang.CloneNotSupportedException: CloneTest
```

## 3. Cloneable 인터페이스

그럼 Cloneable 인터페이스는 어떤 역할을 하는걸까요?

어떤 역할을 하는지 알아보기 위해 Cloneable 인터페이스의 내부를 살펴보겠습니다.

```java
    package java.lang;

    public interface Cloneable {
    }
```

놀랍게도 Cloneable 인터페이스의 내부는 아무것도 없습니다.

보통 일반적인 인터페이스는 구현 클래스에서 미리 구현할 기능을 제공합니다.

그럼 내부에 아무것도 없는 Cloneable 인터페이스는 도대체 어떤 역할을 하는걸까요?

Cloneable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정하는 역할을 합니다.

실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며,

사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다.

이 기대를 만족시키기 위해서는 그 클래스와 모든 상위 클래스는 복잡하고,

강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야 하는데

그 결과, 깨지기 쉽고, 위험하고, 모순적인 매커니즘이 탄생합니다.

즉, 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것입니다.

## 4. clone 메서드의 일반 규약

Object 명세의 clone 메서드 일반 규약을 알아봅시다.

* ``` x.clone() != x ```

* ``` x.clone().getClass() == x.getClass() ```

* ``` x.clone().equals(x) ```

이상의 규약은 참이지만, 반드시 만족해야 하는 것은 아닙니다.

그리고 관례상, 반환된 객체와 원본 객체는 독립적이어야 합니다.

이를 만족하기 위해서는 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정할 수도 있습니다.

(작성중...)