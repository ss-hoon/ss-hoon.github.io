---
title: Item 13. clone 재정의는 주의해서 진행하라
categories: [Effective-Java]
tags: [clone]
toc: true

date: 2022-06-01
last_modified_at: 2022-06-01
---

## 1. 들어가기

clone 메서드를 직접 사용해본 경험이 있나요?

Object를 상속 받는 모든 클래스는 clone 메서드를 호출할 수 있습니다.

하지만, 저는 clone 메서드를 호출해 본 경험은 없네요...

그래서 먼저, clone 메서드가 어떤 역할을 하는지 알아보도록 하겠습니다.

## 2. clone 메서드

clone 메서드는 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성합니다.

즉, 여러 정보를 담은 객체를 복제해서 그 객체와 똑같은 정보를 가진 또 하나의 객체를 생성하는 것입니다.

하지만, 모든 클래스가 이 clone 메서드를 호출할 수 있는 것은 아닙니다.

바로, Cloneable이라는 인터페이스가 구현된 클래스여야 호출 가능합니다.

Cloneable 인터페이스가 구현되지 않았는데 clone 메서드를 호출하게 되면

CloneNotSupportedException 예외가 발생합니다.

```java
/* CloneTest 클래스 */
    public class CloneTest {
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }

/* Client */
    CloneTest test1 = new CloneTest();
    CloneTest test2 = (CloneTest) test1.clone();
```
```
    Exception in thread "main" java.lang.CloneNotSupportedException: CloneTest
```

## 3. Cloneable 인터페이스

그럼 Cloneable 인터페이스는 어떤 역할을 하는걸까요?

어떤 역할을 하는지 알아보기 위해 Cloneable 인터페이스의 내부를 살펴보겠습니다.

```java
    package java.lang;

    public interface Cloneable {
    }
```

놀랍게도 Cloneable 인터페이스의 내부는 아무것도 없습니다.

보통 일반적인 인터페이스는 구현 클래스에서 미리 구현할 기능을 제공합니다.

그럼 내부에 아무것도 없는 Cloneable 인터페이스는 도대체 어떤 역할을 하는걸까요?

Cloneable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정하는 역할을 합니다.

실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며,

사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다.

이 기대를 만족시키기 위해서는 그 클래스와 모든 상위 클래스는 복잡하고,

강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야 하는데

그 결과, 깨지기 쉽고, 위험하고, 모순적인 매커니즘이 탄생합니다.

즉, 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것입니다.

## 4. clone 메서드의 일반 규약

Object 명세의 clone 메서드 일반 규약을 알아봅시다.

* ``` x.clone() != x ```

* ``` x.clone().getClass() == x.getClass() ```

* ``` x.clone().equals(x) ```

이상의 규약은 참이지만, 반드시 만족해야 하는 것은 아닙니다.

그리고 관례상, 반환된 객체와 원본 객체는 독립적이어야 합니다.

이를 만족하기 위해서는 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정할 수도 있습니다.

## 5. clone 메서드의 작성 요령

그럼, 제대로 동작하는 clone 메서드를 한 번 만들어볼까요?

그 전에 상위 클래스에서 이미 제대로 동작하는 clone 메서드를 가지고 있다고 가정해보겠습니다.

1. super.clone 호출

	먼저, super.clone 메서드를 통해 객체를 복제합니다.

	이렇게 복제된 객체는 원본 필드와 똑같은 값을 가지는 완벽한 복제본일 것입니다.

2. 필드 타입을 확인합니다.

	* 모든 타입이 기본 타입이거나 불변 객체를 참조하는 경우

	```java
		public class Book implements Cloneable {
			String name;
			String writer;

			@Override
			public Book clone() {
				try {
					return (Book) super.clone();
				} catch (CloneNotSupportedException e) {
					throw new AssertionError();
				}
			}
		}
	```

	Object의 clone 메서드는 Object를 반환하지만 Book 클래스의 clone 메서드는 Book을 반환합니다.

	이는 Java가 공변 반환 타이핑(Covariant Return Typing)을 지원하기 때문에 가능합니다.

	> * 공변 반환 타이핑 (Covariant Return Typing)
	>
	> 	메서드가 오버라이딩될 때 더 좁은 타입으로 교체 가능

	공변 반환 타이핑을 사용하면 클라이언트에서 형변환을 하지 않아도 되는 장점이 있습니다.

	또한, clone 메서드를 자세히 살펴보면 try-catch 문을 사용한 것을 볼 수 있습니다.

	그 이유는 Object의 clone 메서드가 checked Exception을 던지도록 선언되었기 때문입니다.

	> * 검사 예외 (Checked Exception)
	> 
	> 	반드시 예외처리 해야 하는 예외

	* 가변 객체를 참조하는 경우

	(작성중...)