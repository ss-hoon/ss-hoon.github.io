---
title: Item 30. 이왕이면 제네릭 메서드로 만들라 (작성중)
categories: [Effective-Java]
tags: [Generic]
toc: true
secret: true

date: 2022-08-17
last_modified_at: 2022-08-17
---

## 1. 들어가기

지난 [Item29](../item29)에서는 제네릭을 클래스에 적용하는 방법을 알아보았습니다.

이번에는 제네릭을 메서드에 적용하는 방법에 대해 알아보겠습니다.

## 2. 제네릭 메서드

제네릭 메서드의 작성법은 제네릭 타입 작성법과 비슷합니다.

Raw 타입을 사용한 메서드를 제네릭 메서드로 변경하는 예시를 통해 작성법을 알아봅시다.

```java
/* Raw 타입을 사용한 메서드 */
  public static Set union(Set s1, Set s2) {
    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
  }
```

해당 코드는 컴파일은 되지만 다음의 경고가 발생합니다.

```
  Main.java:9: warning: [unchecked] unchecked call to HashSet(Collection<? extends E>) as a member of the raw type HashSet
        Set result = new HashSet(s1);
                     ^
  where E is a type-variable:
    E extends Object declared in class HashSet

  Main.java:10: warning: [unchecked] unchecked call to addAll(Collection<? extends E>) as a member of the raw type Set
        result.addAll(s2);
                     ^
  where E is a type-variable:
    E extends Object declared in interface Set
```

경고를 없애기 위해서는 타입을 안전하게 만들어야 합니다.

타입을 안전하게 만들기 위해서는 원소 타입을 타입 매개변수로 명시하고

메서드 내부에서도 해당 타입 매개변수만 사용하게 수정하면 됩니다.

다음은 위의 Raw 타입 메서드를 타입 안전하게 만든 제네릭 메서드 예시입니다.

```java
  public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>();
    result.addAll(s2);
    return result;
  }
```

## 3. 제네릭 싱글턴 팩터리

때때로 불변 객체를 여러 타입으로 만들어야 하는 경우가 있습니다.

이런 경우, 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리가 필요한데

이러한 패턴을 **제네릭 싱글턴 팩터리**라고 합니다.

```java
  private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;

  @SuppressWarnings("unchecked")
  public static <T> UnaryOperator<T> identityFunction() {
    return (UnaryOperator<T>) IDENTITY_FN;
  }
```

(작성중...)