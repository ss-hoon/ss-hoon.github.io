---
title: Item 45. 스트림은 주의해서 사용하라
categories: [Effective-Java]
tags: [Stream]
toc: true

date: 2023-01-16
last_modified_at: 2023-01-16
---

## 1. 들어가기

Java 8 이전에는 다량의 데이터 처리 작업은 반복문을 통해서만 가능했습니다.

하지만, Java 8부터 다량의 데이터 처리 작업을 돕기 위해 Stream API가 도입되었습니다.

Stream API가 무엇일까요? 

## 2. Stream API

Stream API는 Stream과 Stream Pipeline라는 두 가지의 핵심 추상 개념을 제공합니다.

* Stream

   * 데이터 원소의 유한 혹은 무한 시퀀스

   * 스트림 원소로 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성기 혹은 다른 스트림이 있음

   <br>

* Stream Pipeline

   * Stream으로 수행하는 연산 단계를 표현하는 개념

   * 중간 연산: 스트림을 어떠한 방식으로 변환

   * 종단 연산: 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가함

   * 지연 평가(Lazy Evaluation) → 무한 스트림 가능

   <br>

Stream API는 Builder와 같이 메서드 연쇄를 지원하는 Fluent API입니다.

즉, Pipeline 하나를 구성하는 모든 호출을 연결해 단 하나의 표현식으로 완성할 수 있는거죠.

또한, Stream API는 다재다능해서 사실상 어떠한 계산도 할 수 있습니다.

하지만 할 수 있다는 뜻이지 해야한다는 뜻이 아니기 때문에 조심해서 사용해야 합니다.

이 Stream API를 제대로 사용하면 프로그램이 짧고 깔끔해진다는 장점이 있으나,

잘못 사용하면 가독성이 좋지 않고 유지보수가 어렵다는 단점이 있기 때문입니다.

그래서 이번에는 언제 Stream API를 사용해야 하는지 알아보겠습니다.

## 3. Stream API 사용처

먼저, Stream API를 잘못 사용한 예를 보겠습니다.

```java
   public clas Anagrams {
      public static void main(String[] args) throws IOException {
         Path dictionary = Paths.get(args[0]);
         int minGroupSize = Integer.parseInt(args[1]);
        
         try(Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                groupingBy(word -> word.chars().sorted()
                           .collect(StringBuilder::new,
                                 (sb, c) -> sb.append((char) c),
                                 StringBuilder::append).toString()))
                           .values().stream()
                           .filter(group -> group.size() >= minGroupSize)
                           .map(group -> group.size() + ": " + group)
                           .forEach(System.out::println);
         }
      } 
   } 
```

한눈에 봐도 코드를 이해하기 어려운 것을 볼 수 있습니다.

이처럼 Stream API를 과용하면 프로그램의 가독성이 좋지 않고 유지보수가 어려워지는 단점이 있습니다.

이번에는 Stream API를 적절하게 사용한 예시를 보겠습니다.

```java
   public class Anagrams {
      public static void main(String[] args) throws IOException {
         Path dictionaryt = Paths.get(args[0]);
         int minGroupSize = Integer.parseInt(args[1]);
        
         try(Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> alphabetize(word))
                 .values().stream()
                 .filter(group -> group.size() >= minGroupSize)
                 .forEach(group -> System.out.println(group.size() + ": " + group));
         }
      }

      private static String alphbetize(String s) {
         char[] a = s.toCharArray();
         Arrays.sort(a);
         return new String(a);
      }
   }
```

확실히 앞의 예시보다 이해하기 쉬워보입니다.

정리하면, 기존 코드는 Stream을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일때만 반영합시다.

다음은 Stream 사용에 안성맞춤인 경우로 이 중 하나를 수행하는 로직이라면 Stream 적용을 고려합시다.

* 원소들의 시퀀스를 일관되게 변환한다.

* 원소들의 시퀀스를 필터링한다.

* 원소들의 시퀀스를 하나의 연산(더하기, 연결하기, 최솟값 구하기)을 사용해 결합한다.

* 원소들의 시퀀스를 컬렉션에 모은다.

* 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

## 4. Stream API로 처리하기 어려운 일

만능인 것처럼 보이는 Stream API도 처리하기 어려운 일이 있습니다.

...