---
title: Item 44. 표준 함수형 인터페이스를 사용하라 (작성중)
categories: [Effective-Java]
tags: [Lambda, FunctionalInterface]
toc: true
secret: true

date: 2023-01-02
last_modified_at: 2023-01-03
---

## 1. 들어가기

람다가 도입되기 전에는 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는

**템플릿 메서드 패턴**을 많이 사용했으나 람다 도입 이후부터는 매력이 크게 줄었습니다.

그 이유는 람다를 통해 함수 객체를 매개변수로 받는 것이 가능해졌기 때문입니다.

그럼, 기존의 템플릿 메서드 패턴을 어떻게 람다로 변경할 수 있을지 알아봅시다.

## 2. 템플릿 메서드 패턴을 람다로 대체하는 방법

먼저, 예시를 보겠습니다.

```java
  protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
    return size() > 100;
  }
```

해당 코드는 LinkedHashMap의 removeEldestEntry 메서드입니다.

Map에 새로운 키가 추가될 때 이 메서드를 호출해 `true`가 반환되면 가장 오래된 원소를 제거하는데요.

잘 동작하지만, 람다를 사용할 수도 있습니다.

그전에 removeEldestEntry 선언을 보면

`Map.Entry<K, V>`를 받아 `boolean`을 반환해야 할 것 같지만 꼭 그렇지는 않습니다.

왜냐하면 removeEldestEntry 내부의 `size()`는 인스턴스 메서드인데

생성자에 넘기는 함수 객체는 인스턴스 메서드가 아니기 때문에 자기 자신도 함수 객체에 넘겨야 합니다.

이를 반영하면 다음과 같은 함수형 인터페이스를 선언하고 사용할 수 있습니다.

```java
/* 함수형 인터페이스 선언 */
  @FunctionalInterface interface EldestEntryRemovalFunction<K, V> {
    boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
  }
```

```java
  /* 함수형 인터페이스 사용법 */
  public class Main {
    public static void main(String[] args) {
      Map<String, Integer> map = CacheMap.of((map1, eldest) -> map1.size() > 2);

      map.put("1", 1);
      map.put("2", 2);
      map.put("3", 3);

      System.out.println(map); // 2 , 3 출력
    }
  }

  class CacheMap<K, V> extends LinkedHashMap<K, V> {

    private EldestEntryRemovalFunction<K, V> function;

    /* 생성자 */
    private CacheMap(EldestEntryRemovalFunction<K, V> function) {
      this.function = function;
    }

    /* 정적 팩터리 메서드 */
    public static <K, V> CacheMap<K, V> of(EldestEntryRemovalFunction<K, V> function) {
      return new CacheMap<K, V>(function);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
      return function.remove(this, eldest);
    }
  }
```

하지만, 이 인터페이스도 잘 동작하기는 하지만, 굳이 사용할 이유는 없습니다.

그 이유는 자바 표준 라이브러리에 이미 같은 모양의 표준 함수형 인터페이스가 있기 때문입니다.

```java
/* 표준 함수형 인터페이스(BiPredicate) 사용법 */
  public class Main {
    public static void main(String[] args) {
      Map<String, Integer> map = CacheMap.of((map1, eldest) -> map1.size() > 2);

      map.put("1", 1);
      map.put("2", 2);
      map.put("3", 3);

      System.out.println(map); // 2 , 3 출력
    }
}

class CacheMap<K, V> extends LinkedHashMap<K, V> {

    private BiPredicate<Map<K, V>,Map.Entry<K, V>> function;

    /* 생성자 */
    private CacheMap(BiPredicate<Map<K, V>,Map.Entry<K, V>> function) {
      this.function = function;
    }

    /* 정적 팩터리 메서드 */
    public static <K, V> CacheMap<K, V> of(BiPredicate<Map<K, V>,Map.Entry<K, V>> function) {
      return new CacheMap<>(function);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
      return function.test(this, eldest);
    }
}
```

## 3. 표준 함수형 인터페이스

표준 함수형 인터페이스는 총 43개의 인터페이스가 있습니다.

하지만, 전부 기억하기란 어렵겠지만, 기본 인터페이스 6개로 유추할 수 있습니다.

기본 인터페이스는 다음과 같습니다.

* `UnaryOperator<T>`

  - 반환 값과 인수 타입이 같은 함수 (인수가 1개)

  - `T apply(T t)`

* `BinaryOperator<T>`

  - 반환 값과 인수 타입이 같은 함수 (인수가 2개)

  - `T apply(T t1, T t2)`

* `Predicate<T>`

  - 인수 하나를 받아 boolean을 반환하는 함수

  - `boolean test(T t)`

* `Function<T, R>`

  - 인수와 반환 타입이 다른 함수

  - `R apply(T t)`

* `Supplier<T>`

  - 인수를 받지 않고 값을 반환하는 함수

  - `T get()`

* `Consumer<T>`

  - 인수 하나를 받고 반환 값은 없는 함수

  - `void accept(T t)`

이렇게 6개의 기본 인터페이스는 `int`, `long`, `double`용으로 각 3개 씩 변형이 있습니다.

`int`를 받는 `Predicate`는 `IntPredicate`가 되는 식이죠.

하지만 `Function`은 조금 다릅니다.

먼저, `Function`의 반환 타입은 매개변수화 되어 다음과 같이

`long` 인수를 받아 `int[]`를 반환하는 Function은 `LongFunction<int[]>` 형태로 사용합니다.

그리고 `Function` 인터페이스는 기본 타입을 반환하는 변형이 총 9개가 있습니다.

입력과 결과의 타입이 항상 다르기 때문에 `SrcToResult` 형태로 사용하는데

예를 들면, `long` 인수를 받아 `int`를 반환하면 `LongToIntFunction` 입니다.

(작성중...)