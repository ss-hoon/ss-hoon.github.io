---
title: Item 34. int 상수 대신 열거 타입을 사용하라
categories: [Effective-Java]
tags: [Enum]
toc: true
secret: true

date: 2022-09-29
last_modified_at: 2022-10-08
---

## 1. 들어가기

우리는 보통 정형화된 데이터를 표현하기 위해 상수를 사용하곤 합니다.

하지만, 상수를 사용하게 되면 다음과 같은 문제를 일으킬 가능성이 있습니다.

```java
  public static final int CARD_JACK = 11;
  public static final int CARD_QUEEN = 12;
  public static final int CARD_KING = 13;

  public static final int FAMILY_BROTHER_AGE = 11;
  public static final int FAMILY_SISTER_AGE = 13;

  public static void main(String[] args) {
    Card card = new Card(FAMILY_BROTHER_AGE);   // 정상 작동
  }
```

이런 문제점을 어떻게 해결할 수 있을까요?

## 2. 열거 타입

다행히 자바는 앞의 문제점을 말끔히 씻어주면서 여러 장점을 안겨주는 방법으로 열거 타입을 제시했습니다.

열거 타입은 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final로 공개합니다.

따라서 클라이언트는 인스턴스를 직접 생성할 수 없기에 열거 타입 인스턴스는 딱 하나씩만 존재하게 됩니다.

🔸 사용법

```java
  public enum Fruit {
    ORANGE, APPLE, MANGO
  }

  public enum Phone {
    APPLE, SAMSUNG
  }
```

🔸장점

  1. 컴파일 시 타입 안전성을 제공한다.

     만약, 메서드의 매개 변수 타입으로 Fruit 열거 타입을 사용했다면

     건네 받은 참조는 null 또는 3가지 타입 중에 하나가 됩니다.

     그러므로 클라이언트는 `bus`와 같이 임의로 값을 지정할 수 없습니다.

      ```java
        public class FruitMarket {
          private Fruit mostPopularFruit;

          public FruitMarket(Fruit fruit) {
            this.mostPopularFruit = fruit
          }
        }

        public static void main(String[] args) {
          FruitMarket market = new FruitMarket(Phone.APPLE);   // 컴파일 오류
        }
      ```

     <br>

  2. 각자 이름공간이 있어 이름이 같은 상수도 사용할 수 있다.

     예를 들어 Fruit 열거 타입과 Phone 열거 타입 각각에 `APPLE`이라는 값이 있어도 공존할 수 있습니다.

     <br>

  3. 열거 타입의 toString 메서드는 출력하기 적합한 문자열을 내어준다.

     상수 필드와 달리 열거 타입은 클래스이기 때문에 메서드를 가질 수 있습니다.

     따라서, toString 메서드를 통해 정보를 출력할 수 있는 적합한 문자열을 내어줄 수 있습니다.

## 3. 열거 타입의 필드와 메서드

또한, 열거 타입에 필드와 메서드를 추가할 수도 있습니다.

예시를 통해 알아봅시다.

```java
  public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS(4.869e+24, 6.052e6),
    EARTH(5.975e+24, 6.378e6),
    MARS(6.419e+23, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN(5.685e+26, 6.027e7),
    URANUS(8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.447e7);
    
    private final double mass;            // 질량(단위: 킬로그램)
    private final double radius;          // 반지름(단위: 미터)
    private final double surfaceGravity;  // 표면중력(단위: m / s^2)
    
    // 중력상수 (단위: m^3 / kg s^2)
    private static final double G = 6.67300E-11;
    
    // 생성자
    Planet(double mass, double radius) {
      this.mass = mass;
      this.radius = radius;
      this.surfaceGravity = G * mass / (radius * radius);
    }
    
    // 해당 행성에서의 무게 반환
    public double surfaceWeight(double mass) {
      return mass * surfaceGravity;
    }
  }
```

위의 예시는 태양계의 여덟 행성을 나타내는 열거 타입입니다.

각 행성에는 질량과 반지름이 있고, 이 두 속성을 이용해 표면 중력을 계산할 수 있습니다.

따라서, 어떤 객체의 질량이 주어지면 그 객체가 행성 표면에 있을 때의 무게도 계산할 수 있습니다.

```java
  Planet.MERCURY.surfaceWeight(70.0);
```

## 4. 열거 타입 값에 따른 분기 처리

(작성중...)