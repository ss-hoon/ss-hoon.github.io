---
title: Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라 (작성중)
categories: [Effective-Java]
tags: [Generic]
toc: true
secret: true

date: 2022-09-07
last_modified_at: 2022-09-17
---

## 1. 들어가기

자바 5에서 제네릭과 함께 가변인수도 함께 추가되었습니다.

가변인수란 무엇일까요?

가변인수에 대해 간단히 알아보겠습니다.

## 2. 가변인수 (varargs)

자바는 오버로딩이라는 기능이 구현되어 있기 때문에

매개변수의 개수와 타입이 달라도 동일한 메소드명으로 기능을 구현할 수 있습니다.

하지만 매개변수의 개수가 무한히 늘어난다면 일일이 매개변수를 하나하나 오버로딩 해줘야할까요?

```java
  String divide(String s1, String s2){...}
  String divide(String s1, String s2, String s3){...}
  String divide(String s1, String s2, String s3, String s4){...}
  String divide(String s1, String s2, String s3, String s4, String s5){...}
```

<div class="div-post-img">
  <img src="{{ site.url }}/assets/img/effective_java/item2/wtf.png" width="30%" height="20%" />
</div>

개발자들은 단순 반복을 매우 싫어합니다.

그래서 JDK 1.5부터 매개변수의 개수를 동적으로 지정해줄 수 있게 되었는데 이것이 바로 **가변인수**입니다.

가변인수를 통해 위의 예시를 바꿔보면 다음과 같습니다.

```java
  String divide(String... s){...}
```

## 3. 제네릭-가변인수의 문제점

다시 돌아와서 자바 5때 함께 추가되었던 제네릭과 가변인수는 서로 잘 어우러지리라 기대했지만,

아쉽게도 그렇지는 않습니다.

런타임 시에 정보를 적게 담고 있는 제네릭과 매개변수화 타입은 실체화되지 않기 때문에

메서드 선언 시 실체화 불가 타입으로 varargs 매개변수를 선언하면 컴파일러가 경고를 보냅니다.

```java
  static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringList;
    objects[0] = intList;               // 힙 오염 발생
    String s = stringLists[0].get(0);   // ClassCastException 발생
  }
```

```
<경고>
  warning: [unchecked] Possible heap pollution from
      parameterized vararg type List<String>

<에러>
  Exception in thread "main" java.lang.ClassCastException
```

이처럼 타입 안전성이 깨지므로 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않습니다.

> 💡 힙 오염(heap pollution)
>
>  보통 선언된 매개변수 타입의 변수로 다른 매개변수 타입의 변수를 가리키는 경우에 발생
>
>  주로 unchecked 경고를 발생시키는 부분에서 발생하고, ClassCastException을 발생시킨다.
>
>  [http://kimalam.blogspot.com/2019/09/java-heap-pollution.html](http://kimalam.blogspot.com/2019/09/java-heap-pollution.html)

## 4. 제네릭-가변인수의 조화

제네릭과 매개변수화 타입의 varargs 매개변수를 받는 메서드는 실무에서 매우 유용합니다.

하지만, 앞서 알아보았듯이 둘을 함께 쓰는 것은 매우 위험합니다.

그럼 제네릭과 가변인수를 함께 사용할 방법은 없는걸까요?

사실, 자바 라이브러리도 이런 메서드를 여럿 제공합니다.

`Arrays.asList(T... a)`, `Collections.addAll(Collection<? super T> c, T... elements)`

다행인 점은 해당 메서드들은 타입 안전하다는 점입니다.

## 5. SafeVarargs 어노테이션

자바 7 전에는 제네릭 가변인수 메서드의 작성자가 사용자 쪽에서 발생하는 경고를 막을 방법이 없었습니다.

그러므로 사용자는 @SuppressWarnings("unchecked") 어노테이션을 달아 경고를 숨겨야 했는데

이는 지루한 작업이고, 가독성을 떨어뜨리며 때로는 진짜 문제를 숨기는 좋지 않는 결과로 이어졌습니다.

그러나 자바 7부터는 @SafeVarargs 어노테이션이 추가되어

제네릭 가변인수 메서드의 작성자가 사용자 쪽에서 발생하는 경고를 숨길 수 있게 되었습니다.

@SafeVarargs 어노테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치로

컴파일러는 이 약속을 믿고 그 메서드가 안전하지 않다는 경고를 하지 않습니다.

그렇기 때문에 메서드가 안전한지 확실하지 않다면 절대 @SafeVarargs 어노테이션을 붙여서는 안됩니다.

그럼 메서드가 안전한지는 어떻게 알 수 있을까요?

## 참조

* [https://sleepyeyes.tistory.com/29](https://sleepyeyes.tistory.com/29)