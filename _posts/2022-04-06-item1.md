---
title: Item 1. Static Factory Method
categories: [Effective-Java]
tags: [Static Factory Method]
toc: true

date: 2022-04-06
last_modified_at: 2022-04-06
---

## 1. 들어가기

> **"생성자 대신 정적 팩터리 메서드를 고려하라"**

**'정적 팩터리 메서드'** 라는 용어를 들어본 적이 있나요?

용어가 다소 생소한 느낌이 있습니다.

지금부터 정적 팩터리 메서드가 무엇인지 알아봅시다.

## 2. Static Factory Method

### 2-1. 의미<br>

먼저 정적 팩터리 메서드라는 용어를 단어로 분리해볼까요?

> 정적(Static), 팩터리(Factory), 메서드(Method)

이 중 Factory라는 단어가 생소할 수 있습니다.

Factory의 사전적 의미는 '무언가를 만드는 공장' 입니다.

그럼 어떤 것을 만드는걸까요?

정적 팩터리 메서드의 Factory는 GoF 디자인 패턴 중 Factory 패턴에서 유래했는데,

WikiPedia에서 Factory 패턴에 대해서 찾아보면 다음과 같이 명시되어 있습니다.

> This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes

그리고 이를 해석하면 다음과 같습니다.

> 객체를 생성하는 인터페이스를 미리 정의하고, 자식 클래스에서 객체를 생성하는 패턴

여기서 Factory라는 것은 '객체 생성을 담당' 이라는 의미입니다.

자, 그럼 앞서 나눴던 정적, 팩터리, 메서드 이 세가지 단어를 합쳐볼까요?

> Static(인스턴스 생성 없이 사용가능하고) Factory(객체 생성을 담당하는) Method(멤버 함수)

드디어 정적 팩터리 메서드 용어의 의미를 알게 되었습니다.

그럼 예시를 통해 어떻게 사용하는지도 알아봅시다.

### 2-2. 예시<br>

우리가 흔히 아는 public 생성자를 통한 객체 생성 방법은 다음과 같습니다.

```
    Person person = new Person();
```

하지만, public 생성자를 통한 객체 생성 방법은

생성자의 매개변수만 보고 해당 객체가 어떤 용도로 사용되는지 파악해야하는 단점이 있습니다.

그래서 대안으로 '정적 팩터리 메서드' 라는 것을 사용할 수 있습니다.

java.lang 패키지에 속하는 Boolean 클래스의 valueOf 메서드를 통해 예시를 알아보겠습니다.

```
/* Boolean.class */

    public final class Boolean implements java.io.Serializable, Comparable<Boolean> {
        public static final Boolean TRUE = new Boolean(true);
        public static final Boolean FALSE = new Boolean(false);

        public static Boolean valueOf(boolean b) {
            return (b ? TRUE : FALSE);
        }
    }
```

Boolean 클래스의 valueOf 메서드는 

boolean 타입을 매개변수로 받아서 Boolean 객체를 생성해 반환하는 메서드입니다.

이쯤에서 이런 궁금증이 들 수 있습니다.

> 어떻게 사용하는지는 알겠는데 왜 '정적 팩터리 메서드' 를 통해 객체를 생성하나요?

한번 더 감싸면서 개발자가 더 많은 작업을 해줘야하는 것 같고...

아직까지는 어떤 이유로 객체를 '정적 팩토리 메서드' 를 통해 생성하는지 모르겠네요. 

장점과 단점을 통해 왜 권장하는지 알아봅시다.

### 2-3. 장점<br>

 1\. 이름을 가질 수 있다.

정적 팩터리 메서드는 Boolean 클래스의 valueOf처럼 이름을 가질 수 있습니다.

이름을 가지게 되면 어떤 장점이 있을까요?

java.math 패키지에 속하는 BigInteger 클래스로 예시를 들어보겠습니다.

```
/* BigInteger.class */

    public class BigInteger extends Number implements Comparable<BigInteger> {
        
        // 생성자
        public BigInteger(int bitLength, int certainty, Random rnd) {
            ...
        } 

        // 정적 팩터리 메서드
        public static BigInteger probablePrime(int bitLength, Random rnd) {
            ...
        }
    }
```

위의 코드를 유지보수 하게 됐다고 가정해봅시다.

만약, 객체를 public 생성자를 통해 생성했다면

개발자가 어떤 의도로 객체를 생성했는지 매개변수만 보고 유추해야합니다.

심지어 유추를 하더라도 개발자가 만든 의도와 다를 확률이 높습니다.

반면, 객체를 정적 팩터리 메서드를 통해 생성했다면

probablePrime 이라는 메서드 이름만 보고도 

개발자가 어떤 의도로 객체를 생성했는지 한눈에 파악할 수 있습니다.

 2\. 시그니처에 제약이 없다.

public 생성자는 다음과 같이 동일한 이름을 가진 여러 개의 생성자를 만들 수 있습니다.

```
/* Person.class */

    public class Person {
        String name, gender;

        public Person() {
            ...
        }

        public Person(String name) {
            ...
        }

        public Person(String name, String gender) {
            ...
        }
    }
```

public 생성자는 여러 개의 생성자를 만들 수 있지만

다음과 같이 시그니처가 같은 경우에는 생성자를 만들지 못하는 문제점이 있습니다.

```
/* Person.class */

    public class Person {
        String name, gender;

        public Person(String name) {
            ...
        }

        public Person(String gender) { // 불가
            ...
        }
    }
```

반면, 정적 팩터리 메서드는 시그니처 제약이 없습니다.

예시를 통해 알아봅시다.

```
/* Person.class */

    public class Person {
        String name, gender;

        public static Person personWithName(String name) {
            Person person = new Person();
            person.name = name;

            return person;
        }

        public static person personWithGender(String gender) {
            Person person = new Person();
            person.gender = gender;

            return person;
        }
    }
```

예시를 보면 두 메서드의 매개변수 타입과 개수가 같지만, 

정적 팩터리 메서드를 통해 다른 객체를 생성할 수 있습니다.

뿐만 아니라 각 메서드 별로 이름이 다르기에

코드 직관성 또한 높아지게 됩니다.

(작성중...)

<div class="highlighter-rouge">
  <pre class="highlight">
    <code>
      📕 개인 기록용 블로그입니다.
      😊 오타나 잘못된 정보가 있을 경우 댓글이나 메일로 말씀해주시면 바로 수정하겠습니다! 😊</code>
  </pre>
</div>