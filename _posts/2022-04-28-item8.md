---
title: Item 8. finalizer와 cleaner 사용을 피하라
categories: [Effective-Java]
tags: [Web, finalizer, cleaner]
toc: true

date: 2022-04-28
last_modified_at: 2022-04-28
---

## 1. 들어가기

Java에서는 finalizer와 cleaner라는 객체 소멸자를 제공합니다.

객체 소멸자하면 C++의 destructor를 떠올릴 수 있는데 둘은 다른 개념입니다.

C++의 소멸자는 특정 객체와 관련된 자원을 회수하는 보편적인 방법이지만,

Java에서는 try-with-resources와 try-finally를 사용하여 GC를 통해 자원을 회수합니다.

이번 Item에서는 finalizer와 cleaner의 사용을 지양하라는데

단점을 통해 그 이유를 알아보겠습니다.

## 2. finalizer와 cleaner의 단점

### 2-1. 즉시 수행된다는 보장이 없다.

반복문을 수행하면서 객체를 생성했다가 해제시키는 예시를 보겠습니다.

```java
  public class Main {

    static class Item {
        private int id;

        Item(int id) {
            this.id = id;
        }

        @Override
        protected void finalize() throws Throwable {
            System.out.println(id + "번 객체 finalize() 실행");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for(int num=1; num<=5; num++) {
            Item item = new Item(num);

            item = null;
            System.gc();
        }
        Thread.sleep(100L);
    }
  }
```

```
  1번 객체 finalize() 실행
  5번 객체 finalize() 실행
  4번 객체 finalize() 실행
  3번 객체 finalize() 실행
  2번 객체 finalize() 실행
```

분명 1번부터 5번까지의 객체를 차례대로 생성했다가 해제시켰는데

출력 값이 1-5-4-3-2번 객체 순으로 이루어진걸로 보아 

finalize() 수행이 즉시 수행된다는 보장이 없음을 알 수 있습니다.

### 2-2. 인스턴스 반납을 지연시킬 수 있다.

finalizer 스레드는 다른 애플리케이션 스레드보다 우선 순위가 낮아서 언제 실행될 지 모릅니다.

즉, finalizer 스레드보다 우선 순위가 높은 스레드가 계속 들어온다면 계속 뒤로 미뤄진다는 의미입니다.

따라서, finalizer 안에 어떤 작업이 있고, 그 작업을 처리하지 못해 대기하고 있다면

계속 쌓이다가 결국 OutOfMemoryException이 발생할 수 있습니다.

### 2-3. 아예 실행되지 않는 경우도 있다.

Java는 finalizer와 cleaner의 수행 시점 뿐만 아니라 수행 여부조차 보장하지 않습니다.

그래서 접근할 수 없는 일부 객체에 대한 종료 작업을 전혀 수행하지 못한 채 프로그램이 종료될 수 있습니다.

따라서, 프로그램의 상태를 변경하는 작업에서는 절대 finalizer나 cleaner 내부에 작성해서는 안됩니다.

추가로, finalizer와 cleaner를 수행하기 위해 

System.gc 메서드나 System.runFinalization 메서드을 사용할 수 있는데

이 또한 실행 가능성을 높여줄 수 있으나 보장해주지 않습니다.

### 2-4. 실행 시 발생하는 오류의 탐색이 어렵다.

이 단점은 cleaner는 해당되지 않고 finalizer만 해당하는 단점입니다.

finalizer 동작 중 발생한 예외는 무시되고, 처리할 작업이 남았더라도 그 순간 종료됩니다.

(작성중...)
