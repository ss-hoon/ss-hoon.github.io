---
title: Item 8. finalizer와 cleaner 사용을 피하라
categories: [Effective-Java]
tags: [Web, finalizer, cleaner]
toc: true

date: 2022-04-28
last_modified_at: 2022-04-28
---

## 1. 들어가기

Java에서는 finalizer와 cleaner라는 객체 소멸자를 제공합니다.

하지만, Java를 사용하면서 객체 소멸자를 따로 사용해본 경험은 없습니다.

그래서 이번 포스트는 객체 소멸자의 사용법과 

이번 Item에서는 왜 객체 소멸자의 사용을 지양하는지 알아봅시다.

## 2. Java 객체 소멸자 사용법

### 2-1. finalizer

```java
  class Test {
    @Override
    protected void finalize() throws Throwable {
        // clean 작업 수행
        System.out.println("clean");
    }
  }
```

finalizer 사용법은 매우 간단합니다.

Object 클래스는 finalizer 메서드를 가지고 있는데 모든 클래스는 Object 클래스를 상속 받기 때문에

finalizer를 오버라이딩해서 사용할 수 있습니다.

### 2-2. cleaner

```java
  import java.lang.ref.Cleaner;

  class Test {
    private static final Cleaner CLEANER = Cleaner.create();
    private final Cleaner.Cleanable cleanable;
    private final CleanData cleanData;

    Test() {
      this.cleanData = new CleanData();
      this.cleanable = CLEANER.register(this, cleanData);
    }

    private static class CleanData implements Runnable {
      @Override
      public void run() {
          // clean 작업 수행
          System.out.println("clean");
      }
    }
  }
```

cleaner의 사용법은 finalizer에 비해 복잡합니다.

Cleaner와 스레드 객체를 생성한 후,

Cleaner.register 메서드로 스레드 객체를 등록해 사용합니다.

## 3. Java 객체 소멸자의 단점

이번 Item에서는 왜 Java 객체 소멸자의 사용을 지양할까요?

단점을 통해 알아봅시다.

### 3-1. 즉시 수행된다는 보장이 없다. 
<hr>

반복문을 수행하면서 객체를 생성했다가 해제시키는 예시를 보겠습니다.

```java
  public class Main {

    static class Item {
        private int id;

        Item(int id) {
            this.id = id;
        }

        @Override
        protected void finalize() throws Throwable {
            System.out.println(id + "번 객체 finalize() 실행");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for(int num=1; num<=5; num++) {
            Item item = new Item(num);

            item = null;
            System.gc();
        }
        Thread.sleep(100L);
    }
  }
```

```
  1번 객체 finalize() 실행
  5번 객체 finalize() 실행
  4번 객체 finalize() 실행
  3번 객체 finalize() 실행
  2번 객체 finalize() 실행
```

분명 1번부터 5번까지의 객체를 차례대로 생성했다가 해제시켰는데

출력 값이 1-5-4-3-2번 객체 순으로 이루어진걸로 보아 

finalize() 수행이 즉시 수행된다는 보장이 없음을 알 수 있습니다.

### 3-2. 인스턴스 반납을 지연시킬 수 있다.
<hr>

finalizer 스레드는 다른 애플리케이션 스레드보다 우선 순위가 낮아서 언제 실행될 지 모릅니다.

즉, finalizer 스레드보다 우선 순위가 높은 스레드가 계속 들어온다면 계속 뒤로 미뤄진다는 의미입니다.

따라서, finalizer 안에 어떤 작업이 있고, 그 작업을 처리하지 못해 대기하고 있다면

계속 쌓이다가 결국 OutOfMemoryException이 발생할 수 있습니다.

### 3-3. 아예 실행되지 않는 경우도 있다.
<hr>

Java는 finalizer와 cleaner의 수행 시점 뿐만 아니라 수행 여부조차 보장하지 않습니다.

그래서 접근할 수 없는 일부 객체에 대한 종료 작업을 전혀 수행하지 못한 채 프로그램이 종료될 수 있습니다.

따라서, 프로그램의 상태를 변경하는 작업에서는 절대 finalizer나 cleaner 내부에 작성해서는 안됩니다.

추가로, finalizer와 cleaner를 수행하기 위해 

System.gc 메서드나 System.runFinalization 메서드을 사용할 수 있는데

이 또한 실행 가능성을 높여줄 수 있으나 보장해주지 않습니다.

### 3-4. 실행 시 발생하는 오류의 탐색이 어렵다.
<hr>

이 단점은 cleaner는 해당되지 않고 finalizer만 해당하는 단점입니다.

finalizer 동작 중 발생한 예외는 무시되고, 처리할 작업이 남았더라도 그 순간 종료됩니다.

이렇게 되면 해당 객체는 자칫 마무리가 되지 않은 상태로 남을 수 있고,

다른 스레드가 해당 객체를 사용하면 어떻게 동작할 지 예측할 수 없습니다.

### 3-5. 심각한 성능 문제도 동반한다.
<hr>

이 책의 저자는 간단한 AutoCloseable 객체를 생성하고 GC로 수거해가기까지의 성능 테스트를 했습니다.

try-with-resources구문으로 만들었을 경우, 12ns 걸리지만

finalizer를 사용한 경우, 550ns가 걸려 50배 정도의 성능이 떨어졌고

cleaner를 사용한 경우, 66ns로 5배 정도의 성능이 떨어졌습니다.

만약, 복잡한 AutoCloseable 객체일 경우, 그 체감은 매우 느릴 것입니다.

### 3-6. 심각한 보안 문제를 일으킬 수 있다.
<hr>

(작성중...)
